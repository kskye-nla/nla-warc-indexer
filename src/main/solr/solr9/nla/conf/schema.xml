<?xml version="1.0" encoding="UTF-8" ?>
<schema name="pandora" version="1.6">
    <types>
        <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true" />
        <fieldType name="int" class="solr.IntPointField" docValues="true" />
        <fieldType name="long" class="solr.LongPointField" docValues="true" />
        <fieldType name="float" class="solr.FloatPointField" docValues="true" />
        <fieldType name="date" class="solr.DatePointField" docValues="true" />
        <fieldType name="bool" class="solr.BoolField" sortMissingLast="true" omitNorms="true" />
        <fieldtype name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField"/>

        <!-- Tokenized text optimised for 'small' fields like titles and such -->
        <fieldtype name="text_trove" class="solr.TextField" positionIncrementGap="100" omitNorms="false">
            <analyzer type="index">
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="(?&lt;=\d)[.,/](\d)" replacement="$1" />
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="[\u2019\u02BC\[\]|.,/]" replacement=" " />
                <tokenizer class="solr.StandardTokenizerFactory" />
                <filter class="solr.CJKWidthFilterFactory" />
                <filter class="solr.ICUFoldingFilterFactory" />
                <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
            </analyzer>
            <analyzer type="query">
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="(?&lt;=\d)[.,/](\d)" replacement="$1" />
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="[\u2019\u02BC\[\]|.,/]" replacement=" " />
                <tokenizer class="solr.StandardTokenizerFactory" />
                <filter class="solr.CJKWidthFilterFactory" />
                <filter class="solr.ICUFoldingFilterFactory" />
                <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true" />
                <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
            </analyzer>
        </fieldtype>

        <!-- Tokenized text optimised for large full text fields (stop word handling via shingles). -->
        <fieldtype name="text_trove_fulltext" class="solr.TextField" positionIncrementGap="100" omitNorms="false">
            <analyzer type="index">
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="(?&lt;=\d)[.,/](\d)" replacement="$1" />
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="[\u2019\u02BC\[\]|.,/]" replacement=" " />
                <tokenizer class="solr.StandardTokenizerFactory" />
                <filter class="solr.CJKWidthFilterFactory" />
                <filter class="solr.ICUFoldingFilterFactory" />
                <!-- Similar to the CommonNGrams filter... but that filter leaves the stop words in place after shingling -->
                <filter class="au.gov.nla.lucene.analysis.StopWordShingleFilterFactory"/>
                <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
            </analyzer>
            <analyzer type="query">
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="(?&lt;=\d)[.,/](\d)" replacement="$1" />
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="[\u2019\u02BC\[\]|.,/]" replacement=" " />
                <tokenizer class="solr.StandardTokenizerFactory" />
                <filter class="solr.CJKWidthFilterFactory" />
                <filter class="solr.ICUFoldingFilterFactory" />
                <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true" />
                <!-- Similar to the CommonNGrams filter... but that filter leaves the stop words in place after shingling -->
                <filter class="au.gov.nla.lucene.analysis.StopWordShingleFilterFactory"/>
                <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
            </analyzer>
        </fieldtype>

        <!-- Tokenized text optimised for large full text fields (as per text_trove_fulltext) which then
         further introduces stemming and an additional layer of CJK handling -->
        <fieldtype name="text_trove_stemmed" class="solr.TextField" positionIncrementGap="100" omitNorms="false">
            <analyzer type="index">
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="(?&lt;=\d)[.,/](\d)" replacement="$1" />
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="[\u2019\u02BC\[\]|.,/]" replacement=" " />
                <tokenizer class="solr.StandardTokenizerFactory" />
                <filter class="solr.CJKWidthFilterFactory" />
                <!-- Stem before folding -->
                <filter class="solr.PorterStemFilterFactory" />
                <filter class="solr.ICUFoldingFilterFactory" />
                <!-- Similar to the CommonNGrams filter... but that filter leaves the stop words in place after shingling -->
                <filter class="au.gov.nla.lucene.analysis.StopWordShingleFilterFactory"/>
                <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
            </analyzer>
            <analyzer type="query">
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="(?&lt;=\d)[.,/](\d)" replacement="$1" />
                <charFilter class="solr.PatternReplaceCharFilterFactory" pattern="[\u2019\u02BC\[\]|.,/]" replacement=" " />
                <tokenizer class="solr.StandardTokenizerFactory" />
                <filter class="solr.CJKWidthFilterFactory" />
                <filter class="solr.ICUTransformFilterFactory" id="Traditional-Simplified" />
                <filter class="solr.ICUTransformFilterFactory" id="Katakana-Hiragana" />
                <!-- Stem before folding -->
                <filter class="solr.PorterStemFilterFactory" />
                <filter class="solr.ICUFoldingFilterFactory"/>
                <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="false" expand="true" />
                <!-- Similar to the CommonNGrams filter... but that filter leaves the stop words in place after shingling -->
                <filter class="au.gov.nla.lucene.analysis.StopWordShingleFilterFactory"/>
                <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
            </analyzer>
        </fieldtype>
    </types>

    <!-- Tokenized URL for the Restrictions code in the indexer to do exact match URL searching without worrying about protocol -->
    <fieldtype name="urlField" class="solr.TextField" positionIncrementGap="100" omitNorms="false">
        <analyzer type="index">
            <tokenizer class="solr.StandardTokenizerFactory" />
            <filter class="solr.LowerCaseFilterFactory"/>
        </analyzer>
        <analyzer type="query">
            <tokenizer class="solr.StandardTokenizerFactory" />
            <filter class="solr.LowerCaseFilterFactory"/>
        </analyzer>
    </fieldtype>

    <fields>
        <field name="auGov" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="pandora" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="pageRank" type="float" indexed="true" stored="true" multiValued="false" omitNorms="true" docValues="true"/>
        <field name="date" type="date" indexed="true" stored="true" multiValued="false" omitNorms="true"/>
        <field name="decade" type="string" indexed="true" stored="true" multiValued="false" docValues="true"/>
        <field name="deliverable" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="deliveryUrl" type="string" indexed="true" stored="true" multiValued="false" docValues="true"/>
        <field name="discoverable" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="classification" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
        <field name="filename" type="string" indexed="true" stored="true" multiValued="false"/>
        <field name="fulltext" type="text_trove_fulltext" indexed="true" stored="true" multiValued="false" omitNorms="false"/>
        <field name="fuzzyFulltext" type="text_trove_stemmed" indexed="true" stored="false" multiValued="false" omitNorms="false"/>
        <!-- These are NOT just copies of one another. The indexer populates them separately. -->
        <!-- This one is tokenized to relevance boost hits on the domain name from general textual searches. -->
        <field name="host" type="text_trove" indexed="true" stored="true" multiValued="false"/>
        <!-- This one is has the input string reversed by the indexer to support left-anchored wildcards in sub-domains. -->
        <field name="hostReversed" type="string" indexed="true" stored="true" multiValued="false"/>
        <field name="id" type="string" indexed="true" stored="true" multiValued="false" docValues="true"/>
        <field name="lastIndexed" type="date" indexed="true" stored="true" multiValued="false" omitNorms="true" default="NOW" docValues="true"/>
        <field name="metadata" type="text_trove_fulltext" indexed="true" stored="true" multiValued="true"/>
        <field name="pandoraUrl" type="string" indexed="true" stored="true" multiValued="false" docValues="true"/>
        <field name="ruleId" type="int" indexed="true" stored="true" multiValued="false" omitNorms="true" docValues="true"/>
        <field name="searchCategory" type="string" indexed="true" stored="true" multiValued="false"/>
        <field name="site" type="string" indexed="true" stored="true" multiValued="false" docValues="true"/>
        <field name="siteHashAndYear" type="long" indexed="false" stored="true" multiValued="false" docValues="true"/>
        <field name="ogSite" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
        <field name="textError" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="title" type="text_trove" indexed="true" stored="true" multiValued="false" omitNorms="true"/>
        <field name="ogTitle" type="text_trove" indexed="true" stored="true" multiValued="true" omitNorms="true"/>
        <field name="h1" type="text_trove" indexed="true" stored="true" multiValued="true" omitNorms="true"/>
        <field name="linkText1" type="text_trove" indexed="true" stored="true" multiValued="true" omitNorms="true"/>
        <field name="linkText2" type="text_trove" indexed="true" stored="true" multiValued="true" omitNorms="true"/>
        <field name="linkText3" type="text_trove" indexed="true" stored="true" multiValued="true" omitNorms="true"/>
        <field name="linkText4" type="text_trove" indexed="true" stored="true" multiValued="true" omitNorms="true"/>
        <field name="url" type="string" indexed="true" stored="true" multiValued="false" docValues="true"/>
        <field name="urlText" type="text_trove" indexed="true" stored="false" multiValued="false" omitNorms="true"/>
        <field name="urlTokenized" type="urlField" indexed="true" stored="false" multiValued="false" omitNorms="true"/>
        <field name="year" type="int" indexed="true" stored="true" multiValued="false" docValues="true"/>

        <field name="queuedForClassification" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="classificationFailed" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="imageHumanSafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="imageAutoSafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="imageAutoMaybeSafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="imageAutoMaybeUnsafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="imageAutoUnsafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="imageHumanUnsafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="textHumanSafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="textAutoSafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="textAutoMaybeSafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="textAutoMaybeUnsafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="textAutoUnsafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="textContentkeeperUnsafe" type="bool" indexed="true" stored="true" multiValued="false"/>
        <field name="textHumanUnsafe" type="bool" indexed="true" stored="true" multiValued="false"/>

        <field name="_version_" type="long" indexed="true" stored="true" multiValued="false" omitNorms="true"/>
        <dynamicField name="*" type="ignored" multiValued="true"/>
    </fields>

    <uniqueKey>id</uniqueKey>

    <copyField source="url" dest="urlText"/>
    <copyField source="deliveryUrl" dest="urlTokenized"/>
    <copyField source="fulltext" dest="fuzzyFulltext"/>
</schema>