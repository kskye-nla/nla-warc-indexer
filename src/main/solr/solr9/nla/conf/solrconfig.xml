<?xml version="1.0" encoding="UTF-8" ?>
<config>
  <abortOnConfigurationError>${solr.abortOnConfigurationError:true}</abortOnConfigurationError>

  <luceneMatchVersion>LUCENE_CURRENT</luceneMatchVersion>

  <dataDir>${solr.data.webarchive.dir:}</dataDir>
  <directoryFactory name="DirectoryFactory" class="${solr.directoryFactory:solr.NIOFSDirectoryFactory}"/>

  <indexingConfig>
    <!-- Values here affect all index writers and act as a default unless overridden. -->
    <ramBufferSizeMB>1000</ramBufferSizeMB>
    <useCompoundFile>false</useCompoundFile>
    <mergeFactor>10</mergeFactor>
    <checkIntegrityAtMerge>true</checkIntegrityAtMerge>
    <reopenReaders>true</reopenReaders>

    <!-- This is non-default... but faster. We only ever have 1 JVM access segment data -->
    <lockType>single</lockType>
    <unlockOnStartup>false</unlockOnStartup>
    <writeLockTimeout>1000</writeLockTimeout>
    <deletionPolicy class="solr.SolrDeletionPolicy">
      <str name="maxCommitsToKeep">1</str>
      <str name="maxOptimizedCommitsToKeep">0</str>
    </deletionPolicy>
  </indexingConfig>

  <jmx/>

  <!-- *************************
       *     Update Handlers   *
       ************************* -->
  <!-- the default high-performance update handler -->
  <updateHandler class="solr.DirectUpdateHandler2">
    <updateLog>
      <str name="dir">${solr.ulog.dir:}</str>
    </updateLog>

    <!-- This is about how often data is written to segment files from the transaction log.
     Mostly no need to touch it. -->
    <autoCommit>
      <maxDocs>1000</maxDocs>
      <maxTime>120000</maxTime>
      <openSearcher>false</openSearcher>
    </autoCommit>

    <autoSoftCommit>
      <!-- Documents become visible 10 minutes after indexing (at most).
           Web archives only receives write traffic at night, so setting this
            value as high as reasonably possible will improve indexing times-->
      <!-- 10 minutes... when in 'normal' usage-->
      <maxTime>600000</maxTime>
    </autoSoftCommit>
  </updateHandler>

  <!-- *************************
       *    Request  Handlers  *
       ************************* -->
  <!-- realtime get handler, guaranteed to return the latest stored fields of
       any document, without the need to commit or open a new searcher.  The
       current implementation relies on the updateLog feature being enabled.

       ** WARNING **
       Do NOT disable the realtime get handler at /get if you are using
       SolrCloud otherwise any leader election will cause a full sync in ALL
       replicas for the shard in question. Similarly, a replica recovery will
       also always fetch the complete index from the leader because a partial
       sync will not be possible in the absence of this handler.
  -->
  <requestHandler name="/get" class="solr.RealTimeGetHandler">
    <lst name="defaults">
      <str name="omitHeader">true</str>
      <str name="wt">json</str>
      <str name="indent">true</str>
    </lst>
  </requestHandler>
  <requestHandler name="/replication" class="solr.ReplicationHandler">
    <lst name="defaults">
      <str name="maxWriteMBPerSec">20</str>
    </lst>
  </requestHandler>

  <requestHandler name="/select" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <int name="rows">10</int>
      <str name="df">fulltext</str>
    </lst>
    <arr name="components">
      <str>query</str>
      <str>nlahighlight</str>
      <str>debug</str>
    </arr>
  </requestHandler>


  <requestHandler name="/group" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="shards.qt">/groupBackend</str>
      <str name="wt">xml</str>

      <!-- Query settings -->
      <str name="defType">edismax</str>
      <!-- Query Fields: the fields to search with their relevant importance -->
      <str name="qf">id^100.0 host^8 urlText^6.0 title^10.0 linkText1^2.5 linkText2^2.0 linkText3^1.0 linkText4^0.5  h1^1.0 metadata^0.5 fulltext^0.2</str>
      <!-- Increase the boost if the terms also appear as a phrase in one of these fields -->
      <str name="pf">id^100.0 host^10 urlText^8.0 title^20.0 linkText1^5.0 linkText2^4.0 linkText3^2.0 linkText4^1.0 h1^1.5 metadata^1 fulltext^1</str>
      <str name="boost">pageRank</str>
      <!-- Allow for some inaccuracy/variation in the location of words within that phrase - ps = phrase slop -->
      <str name="ps">5</str>
      <!-- Same as 'ps' but this applies only to phrases explicitly provided by the user in the query - qs = query slop -->
      <str name="qs">1</str>
      <!-- Unfielded searches go to these fields. Not this is redundant. Supplied here for the sake of completeness,
           as it is a core solr parameter, but the dismax 'qf' provides the same end result but does a better job. -->
      <str name="df">fulltext</str>
      <str name="rows">20</str>
      <str name="fl">id,url,deliveryUrl,pandoraUrl,protocol,date,title,site,contentType,searchCategory,score</str>
      <!-- q.op = 'AND' will first insert missing operators, then mm = 0% will respect OR's -->
      <str name="q.op">AND</str>
      <str name="mm">0%</str>

      <!-- Highlighting defaults -->
      <str name="hl">on</str>
      <str name="hl.fl">title,url,fulltext</str>
      <str name="hl.snippets">2</str>
      <str name="hl.encoder">html_lt</str>

      <!-- Aliasing - legacy field names and API entries -->
      <str name="f.text.qf">fulltext^1.0</str>
      <str name="f.lastupdated.qf">lastIndexed</str>

      <!-- Grouping -->
      <str name="group">true</str>
      <str name="group.field">site</str>
      <str name="group.limit">1</str>
      <!--  <str name="group.field.site">deliveryUrl</str> -->
    </lst>
    <arr name="components">
      <str>query</str>
      <str>nlahighlight</str>
      <str>debug</str>
    </arr>
  </requestHandler>
  <requestHandler name="/groupFull" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="shards.qt">/groupBackend</str>
      <str name="wt">xml</str>

      <!-- Query settings -->
      <str name="defType">edismax</str>
      <!-- Query Fields: the fields to search with their relevant importance -->
      <str name="qf">id^100.0 host^8 urlText^6.0 title^10.0 linkText1^2.5 linkText2^2.0 linkText3^1.0 linkText4^0.5  h1^1.0 metadata^0.5 fulltext^0.2 fuzzyFulltext^0.1</str>
      <!-- Increase the boost if the terms also appear as a phrase in one of these fields -->
      <str name="pf">id^100.0 host^10 urlText^8.0 title^20.0 linkText1^5.0 linkText2^4.0 linkText3^2.0 linkText4^1.0 h1^1.5 metadata^1 fulltext^1 fuzzyFulltext^0.5</str>
      <str name="boost">pageRank</str>
      <!-- Allow for some inaccuracy/variation in the location of words within that phrase - ps = phrase slop -->
      <str name="ps">5</str>
      <!-- Same as 'ps' but this applies only to phrases explicitly provided by the user in the query - qs = query slop -->
      <str name="qs">1</str>
      <!-- Unfielded searches go to these fields. Not this is redundant. Supplied here for the sake of completeness,
           as it is a core solr parameter, but the dismax 'qf' provides the same end result but does a better job. -->
      <str name="df">fulltext,fuzzyFulltext</str>
      <str name="rows">20</str>
      <str name="fl">id,url,deliveryUrl,pandoraUrl,protocol,date,title,site,contentType,searchCategory,score</str>
      <!-- q.op = 'AND' will first insert missing operators, then mm = 0% will respect OR's -->
      <str name="q.op">AND</str>
      <str name="mm">0%</str>

      <!-- Highlighting defaults -->
      <str name="hl">on</str>
      <str name="hl.fl">title,url,fulltext</str>
      <str name="hl.snippets">2</str>
      <str name="hl.encoder">html_lt</str>

      <!-- Aliasing - legacy field names and API entries -->
      <str name="f.text.qf">fulltext^1.0</str>
      <str name="f.lastupdated.qf">lastIndexed</str>

      <!-- Grouping -->
      <str name="group">true</str>
      <str name="group.field">site</str>
      <str name="group.limit">1</str>
      <!--  <str name="group.field.site">deliveryUrl</str> -->
    </lst>
    <arr name="components">
      <str>query</str>
      <str>nlahighlight</str>
      <str>debug</str>
    </arr>
  </requestHandler>
  <requestHandler name="/groupSingle" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="shards.qt">/groupSingleBackend</str>
      <str name="wt">xml</str>

      <!-- Query settings -->
      <str name="defType">edismax</str>
      <!-- Query Fields: the fields to search with their relevant importance -->
      <str name="qf">id^100.0 host^8 urlText^6.0 title^10.0 linkText1^2.5 linkText2^2.0 linkText3^1.0 linkText4^0.5  h1^1.0 metadata^0.5 fulltext^0.2</str>
      <!-- Increase the boost if the terms also appear as a phrase in one of these fields -->
      <str name="pf">id^100.0 host^10 urlText^8.0 title^20.0 linkText1^5.0 linkText2^4.0 linkText3^2.0 linkText4^1.0 h1^1.5 metadata^1 fulltext^1</str>
      <str name="boost">pageRank</str>
      <!-- Allow for some inaccuracy/variation in the location of words within that phrase - ps = phrase slop -->
      <str name="ps">5</str>
      <!-- Same as 'ps' but this applies only to phrases explicitly provided by the user in the query - qs = query slop -->
      <str name="qs">1</str>
      <!-- Unfielded searches go to these fields. Not this is redundant. Supplied here for the sake of completeness,
           as it is a core solr parameter, but the dismax 'qf' provides the same end result but does a better job. -->
      <str name="df">fulltext</str>
      <str name="rows">20</str>
      <str name="fl">id,url,deliveryUrl,pandoraUrl,protocol,date,title,site,contentType,searchCategory,score</str>
      <!-- q.op = 'AND' will first insert missing operators, then mm = 0% will respect OR's -->
      <str name="q.op">AND</str>
      <str name="mm">0%</str>

      <!-- Highlighting defaults -->
      <str name="hl">on</str>
      <str name="hl.fl">title,url,fulltext</str>
      <str name="hl.snippets">2</str>
      <str name="hl.encoder">html_lt</str>

      <!-- Aliasing - legacy field names and API entries -->
      <str name="f.text.qf">fulltext^1.0</str>
      <str name="f.lastupdated.qf">lastIndexed</str>

      <!-- Grouping -->
      <str name="group">true</str>
      <str name="group.field">deliveryUrl</str>
      <str name="group.limit">1</str>
    </lst>
    <arr name="components">
      <str>query</str>
      <str>nlahighlight</str>
      <str>debug</str>
    </arr>
  </requestHandler>

  <requestHandler name="/groupSingleFull" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="shards.qt">/groupSingleBackend</str>
      <str name="wt">xml</str>

      <!-- Query settings -->
      <str name="defType">edismax</str>
      <!-- Query Fields: the fields to search with their relevant importance -->
      <str name="qf">id^100.0 host^8 urlText^6.0 title^10.0 linkText1^2.5 linkText2^2.0 linkText3^1.0 linkText4^0.5  h1^1.0 metadata^0.5 fulltext^0.2 fuzzyFulltext^0.1</str>
      <!-- Increase the boost if the terms also appear as a phrase in one of these fields -->
      <str name="pf">id^100.0 host^10 urlText^8.0 title^20.0 linkText1^5.0 linkText2^4.0 linkText3^2.0 linkText4^1.0 h1^1.5 metadata^1 fulltext^1 fuzzyFulltext^0.5</str>
      <str name="boost">pageRank</str>
      <!-- Allow for some inaccuracy/variation in the location of words within that phrase - ps = phrase slop -->
      <str name="ps">5</str>
      <!-- Same as 'ps' but this applies only to phrases explicitly provided by the user in the query - qs = query slop -->
      <str name="qs">1</str>
      <!-- Unfielded searches go to these fields. Not this is redundant. Supplied here for the sake of completeness,
           as it is a core solr parameter, but the dismax 'qf' provides the same end result but does a better job. -->
      <str name="df">fulltext,fuzzyFulltext</str>
      <str name="rows">20</str>
      <str name="fl">id,url,deliveryUrl,pandoraUrl,protocol,date,title,site,contentType,searchCategory,score</str>
      <!-- q.op = 'AND' will first insert missing operators, then mm = 0% will respect OR's -->
      <str name="q.op">AND</str>
      <str name="mm">0%</str>

      <!-- Highlighting defaults -->
      <str name="hl">on</str>
      <str name="hl.fl">title,url,fulltext</str>
      <str name="hl.snippets">2</str>
      <str name="hl.encoder">html_lt</str>

      <!-- Aliasing - legacy field names and API entries -->
      <str name="f.text.qf">fulltext^1.0</str>
      <str name="f.lastupdated.qf">lastIndexed</str>

      <!-- Grouping -->
      <str name="group">true</str>
      <str name="group.field">deliveryUrl</str>
      <str name="group.limit">1</str>
    </lst>
    <arr name="components">
      <str>query</str>
      <str>nlahighlight</str>
      <str>debug</str>
    </arr>
  </requestHandler>

  <!-- This is basically a copy of a normal /select query, but it is used by /simpleSearch for backend/distributed search.
       This keeps the statistics sepearate per front-end handler in terms of measuring distributed impact. -->
  <requestHandler name="/simpleBackend" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <int name="rows">10</int>
      <str name="df">fulltext</str>
    </lst>
    <arr name="components">
      <str>query</str>
      <str>nlahighlight</str>
      <str>debug</str>
    </arr>
  </requestHandler>
  <requestHandler name="/groupBackend" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <int name="rows">10</int>
      <str name="df">fulltext</str>
    </lst>
    <arr name="components">
      <str>query</str>
      <str>nlahighlight</str>
      <str>debug</str>
    </arr>
  </requestHandler>
  <requestHandler name="/groupSingleBackend" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <int name="rows">10</int>
      <str name="df">fulltext</str>
    </lst>
    <arr name="components">
      <str>query</str>
      <str>nlahighlight</str>
      <str>debug</str>
    </arr>
  </requestHandler>
  <!-- As per /simpleBackend -->
  <requestHandler name="/titleBackend" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <int name="rows">10</int>
      <str name="df">title</str>
    </lst>
    <arr name="components">
      <str>query</str>
      <str>nlahighlight</str>
      <str>debug</str>
    </arr>
  </requestHandler>
  <requestHandler name="/urlBackend" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <int name="rows">1</int>
      <str name="df">url</str>
    </lst>
    <arr name="components">
      <str>query</str>
    </arr>
  </requestHandler>

  <!-- Simple Search box -->
  <requestHandler name="/simpleSearch" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="shards.qt">/simpleBackend</str>
      <str name="wt">xml</str>

      <!-- Query settings -->
      <str name="defType">edismax</str>
      <!-- Query Fields: the fields to search with their relevant importance -->
      <str name="qf">id^100.0 host^8 urlText^6.0 title^10.0 linkText1^2.5 linkText2^2.0 linkText3^1.0 linkText4^0.5  h1^1.0 metadata^0.5 fulltext^0.2 fuzzyFulltext^0.1</str>
      <!-- Increase the boost if the terms also appear as a phrase in one of these fields -->
      <str name="pf">id^100.0 host^10 urlText^8.0 title^20.0 linkText1^5.0 linkText2^4.0 linkText3^2.0 linkText4^1.0 h1^1.5 metadata^1 fulltext^1 fuzzyFulltext^0.5</str>
      <str name="boost">pageRank</str>
      <!-- Allow for some inaccuracy/variation in the location of words within that phrase - ps = phrase slop -->
      <str name="ps">5</str>
      <!-- Same as 'ps' but this applies only to phrases explicitly provided by the user in the query - qs = query slop -->
      <str name="qs">1</str>
      <!-- Unfielded searches go to these fields. Not this is redundant. Supplied here for the sake of completeness,
           as it is a core solr parameter, but the dismax 'qf' provides the same end result but does a better job. -->
      <str name="df">fulltext,fuzzyFulltext</str>
      <str name="rows">20</str>
      <str name="fl">id,url,deliveryUrl,pandoraUrl,protocol,date,title,site,contentType,searchCategory,score</str>
      <!-- q.op = 'AND' will first insert missing operators, then mm = 0% will respect OR's -->
      <str name="q.op">AND</str>
      <str name="mm">0%</str>

      <!-- Highlighting defaults -->
      <str name="hl">on</str>
      <str name="hl.fl">title,url,fulltext</str>
      <str name="hl.snippets">2</str>
      <str name="hl.encoder">html_lt</str>

      <!-- Aliasing - legacy field names and API entries -->
      <str name="f.text.qf">fulltext^1.0</str>
      <str name="f.lastupdated.qf">lastIndexed</str>
    </lst>
    <arr name="components">
      <str>query</str>
      <str>nlahighlight</str>
      <str>debug</str>
    </arr>
  </requestHandler>

  <!-- Title search from the advanced search screen -->
  <requestHandler name="/titleSearch" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="shards.qt">/titleBackend</str>
      <str name="wt">xml</str>

      <!-- Query settings -->
      <str name="defType">edismax</str>
      <!-- Query Fields: the fields to search with their relevant importance -->
      <str name="qf">id^10.0 title</str>
      <!-- Increase the boost if the terms also appear as a phrase in one of these fields -->
      <str name="pf">title</str>
      <!-- Allow for some inaccuracy/variation in the location of words within that phrase - ps = phrase slop -->
      <str name="ps">5</str>
      <!-- Same as 'ps' but this applies only to phrases explicitly provided by the user in the query - qs = query slop -->
      <str name="qs">1</str>
      <!-- Unfielded searches go to these fields. Not this is redundant. Supplied here for the sake of completeness,
           as it is a core solr parameter, but the dismax 'qf' provides the same end result but does a better job. -->
      <str name="df">title</str>
      <str name="rows">20</str>
      <str name="fl">id,url,protocol,date,title,site,contentType,searchCategory,score</str>
      <!-- q.op = 'AND' will first insert missing operators, then mm = 0% will respect OR's -->
      <str name="q.op">AND</str>
      <str name="mm">0%</str>

      <!-- Highlighting defaults -->
      <str name="hl">on</str>
      <str name="hl.fl">title</str>
      <str name="hl.snippets">2</str>
      <str name="hl.encoder">html_lt</str>

      <!-- Aliasing - legacy field names and API entries -->
      <str name="f.text.qf">fulltext^1.0</str>
      <str name="f.lastupdated.qf">lastIndexed</str>
    </lst>
    <arr name="components">
      <str>query</str>
      <str>nlahighlight</str>
      <str>debug</str>
    </arr>
  </requestHandler>

  <!-- URL search for exact matches -->
  <requestHandler name="/urlSearch" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="shards.qt">/urlBackend</str>
      <str name="wt">xml</str>

      <str name="df">url</str>
      <str name="rows">1</str>
      <str name="fl">id,url,deliveryUrl,pandoraUrl,protocol,date,title,site,contentType,searchCategory,score</str>
    </lst>
    <arr name="components">
      <str>query</str>
    </arr>
  </requestHandler>

  <!--<requestHandler name="/group" class="org.apache.solr.handler.component.SearchHandler">-->
  <!--<lst name="defaults">-->
  <!--<str name="echoParams">explicit</str>-->
  <!--<str name="shards.qt">/group</str>-->
  <!--</lst>-->

  <!--<arr name="components">-->
  <!--&lt;!&ndash;<str>SingleBusinessCommonQueryComponentElimination</str>&ndash;&gt;-->
  <!--<str>NLADomainGroupingQueryComponent</str>-->
  <!--&lt;!&ndash;<str>facet</str>&ndash;&gt;-->
  <!--<str>highlight</str>-->
  <!--<str>debug</str>-->
  <!--</arr>-->
  <!--</requestHandler>-->

  <requestHandler name="/update" class="solr.UpdateRequestHandler">
  </requestHandler>

  <requestHandler name="/admin/ping" class="solr.PingRequestHandler">
    <lst name="invariants">
      <str name="q">solrpingquery</str>
    </lst>
    <lst name="defaults">
      <str name="echoParams">all</str>
    </lst>
  </requestHandler>
  <requestHandler name="/analysis/field" startup="lazy" class="solr.FieldAnalysisRequestHandler"/>
  <requestHandler name="/analysis/document" class="solr.DocumentAnalysisRequestHandler" startup="lazy"/>

  <requestHandler name="/debug/dump" class="solr.DumpRequestHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="echoHandler">true</str>
    </lst>
  </requestHandler>

  <requestHandler name="/tvrh" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <str name="df">fulltext</str>
      <bool name="tv">true</bool>
    </lst>
    <arr name="last-components">
      <str>tvComponent</str>
    </arr>
  </requestHandler>

  <requestHandler name="/terms" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <bool name="terms">true</bool>
      <bool name="distrib">true</bool>
      <str name="shards.qt">/terms</str>
    </lst>
    <arr name="components">
      <str>terms</str>
    </arr>
  </requestHandler>

  <!-- *************************
       *   Search Components   *
       ************************* -->
  <!-- Search components are registered to SolrCore and used by Search Handlers
     By default, the following components are avaliable:

     <searchComponent name="query"     class="org.apache.solr.handler.component.QueryComponent" />
     <searchComponent name="facet"     class="org.apache.solr.handler.component.FacetComponent" />
     <searchComponent name="mlt"       class="org.apache.solr.handler.component.MoreLikeThisComponent" />
     <searchComponent name="highlight" class="org.apache.solr.handler.component.HighlightComponent" />
     <searchComponent name="debug"     class="org.apache.solr.handler.component.DebugComponent" />

     If you register a searchComponent to one of the standard names, that will be used instead.
  -->

  <!--<searchComponent name="NLADomainGroupingQueryComponent" class="au.gov.nla.solr.handler.component.NLADomainGroupingQueryComponent" lib="nlasolr" version="1" />-->
  <!--<listener event="newSearcher" name="NLADomainGroupingQueryComponentListener" class="au.gov.nla.solr.handler.component.NLADomainGroupingQueryComponent" lib="nlasolr" version="1" />-->

  <!-- Terms -->
  <searchComponent name="tvComponent" class="solr.TermVectorComponent"/>
  <searchComponent name="terms" class="org.apache.solr.handler.component.NLATermsComponent"/>

  <!-- Highlighting -->
  <searchComponent name="nlahighlight" class="solr.HighlightComponent">
    <highlighting class="au.gov.nla.solr.highlight.NLASolrHighlighter">
      <fragmenter name="gap" class="org.apache.solr.highlight.GapFragmenter" default="true">
        <lst name="defaults">
          <int name="hl.fragsize">100</int>
        </lst>
      </fragmenter>
      <fragmenter name="regex" class="org.apache.solr.highlight.RegexFragmenter">
        <lst name="defaults">
          <int name="hl.fragsize">70</int>
          <float name="hl.regex.slop">0.5</float>
          <str name="hl.regex.pattern">[-\w ,/\n\"']{20,200}</str>
        </lst>
      </fragmenter>
      <formatter name="html" class="org.apache.solr.highlight.HtmlFormatter" default="true">
        <lst name="defaults">
          <str name="hl.simple.pre"><![CDATA[<em>]]></str>
          <str name="hl.simple.post"><![CDATA[</em>]]></str>
        </lst>
      </formatter>
      <encoder name="html_lt" class="au.gov.nla.solr.highlight.HtmlLtEncoder"/>
    </highlighting>
  </searchComponent>

  <!-- *************************
       *      Query Config     *
       ************************* -->
  <query>
    <maxBooleanClauses>1024</maxBooleanClauses>

    <filterCache class="solr.CaffeineCache" size="100" initialSize="100" autowarmCount="0"/>
    <enableLazyFieldLoading>true</enableLazyFieldLoading>
    <queryResultWindowSize>20</queryResultWindowSize>
    <queryResultMaxDocsCached>200</queryResultMaxDocsCached>
    <useColdSearcher>true</useColdSearcher>
    <maxWarmingSearchers>1</maxWarmingSearchers>
    <slowQueryThresholdMillis>10000</slowQueryThresholdMillis>
  </query>

  <requestDispatcher handleSelect="false">
    <requestParsers enableRemoteStreaming="true" multipartUploadLimitInKB="2048000" formdataUploadLimitInKB="2048"/>
    <httpCaching never304="true"/>
  </requestDispatcher>

  <admin>
    <defaultQuery>*:*</defaultQuery>
  </admin>
</config>